Redux-Saga

Watcher - следит за выполнением actions в нашем приложении;
Worker - выполняет бизнес-логику, асинхронные операции;
Effects - блокирующие выпонение(take, call) и неблокирующие(fork, spawn)

Эффекты - выполняют какое-либо дейсвтие: возврают простые объекты, которые содержат инстукции как обрабатывать redux-saga-middleware
1) put (выполняет роль dispatch) - yield put ({type: "SET-PEOPLE", payload: data})
2) take - указывает middleware ждать dispatch указанного действия; (take ('CLICK'))
3) takeEvery - используется в watcher для декларативной записи actions и workera;(takeEvery("CLICK", workerSaga))
4) takeLatest - при срабатывании action несколько раз - worker отработает только на последний раз и проигнорирует предыдущие запросы - (takeLatest("CLICK", workerSaga))
5) takeLeading - автоматически отменяет любую следующую задачу саги, запущенную позднее, если первая запущенная программа еще выполняется - (takeLeading("CLICK", workerSaga))


Для вызова асинхронных действий, но блокируют выполнение - требуется последовательное выполнение запросов помогает тестировать приложение: 

4) call - выполняет переданную функцию. Если функция вернет Promise, то приостанавливает сагу до тех пор, пока Promise не вызовет resolve. Второй параметр - аргументы для перерданной функции.

const people = yield call(swapiGet, "people")
const planets = yield call(swapiGet, "planets")


5) Для асинхронных действий, но выполняются параллельно, не блокируют код:

fork - эффект, который указывает middleware выполнить неблокирующий вызов переданной функции:

export function* workerSaga() {
  yield fork(loadPeople)
  yield fork(loadPlanets)
}

Асинхронные операции выполняются параллельно и не ждут друг друга.

ВАЖНО!!!! 

Все форкнутые и разветвленные задачи -  прикрепленны к своим родителям.
Т.е. внутри workera 2 отдельных функции, которые использованы с помощью fork, и если в одной будет ошибка - worker заблокируется.
Любая ошибка, которая происходит в дочерней задаче, которая описана с помощью fork - она всплывает к родительским задачам.
Если ошибка произошла - родительская задача блокируется и не будет выполнена.

6) spawn - создает параллельную задачу в корне саги, сам процесс не привязан к родителю. Следовательно ошибка в данной функции не заблокирует worker.

yield spawn(loadPeople)


7) join - заблокировать не блокирующую задачу и получить ее результат;
